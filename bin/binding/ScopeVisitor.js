// Generated by CoffeeScript 1.10.0

/*
@author  Oleg Mazko <o.mazko@mail.ru>
@license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function() {
  var Dict, FieldScope, GenericVisitor, MemberScope, MicroVisitor, ScopeVisitor, VarScope, builders, estypes, ref,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  estypes = require('ast-types');

  Dict = require('../collections/Dict');

  ref = require('../GenericVisitor'), GenericVisitor = ref.GenericVisitor, MicroVisitor = ref.MicroVisitor;

  builders = estypes.builders;

  VarScope = (function() {
    var VarModel;

    VarModel = (function() {
      function VarModel(type1, _static) {
        this.type = type1;
        this["static"] = _static;
      }

      return VarModel;

    })();

    function VarScope(src, arg) {
      var _unique_var_validator, _vars;
      if (src == null) {
        src = null;
      }
      _vars = (arg != null ? arg : {
        _vars: new Dict
      })._vars;
      this.contains = _vars.contains;
      this.get_type = function(name, def) {
        var ref1;
        if (def == null) {
          def = null;
        }
        return ((ref1 = _vars.get_value(name)) != null ? ref1.type : void 0) || def;
      };
      this.is_static = function(name) {
        var ref1;
        return !!((ref1 = _vars.get_value(name)) != null ? ref1["static"] : void 0);
      };
      this.clone = function() {
        return new this.constructor(null, {
          _vars: _vars.clone()
        });
      };
      _unique_var_validator = [];
      this.collect_from = function(src) {
        var VarCollector, safe_vars_set;
        safe_vars_set = function() {
          var args, nm;
          nm = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (indexOf.call(_unique_var_validator, nm) >= 0) {
            throw "ASSERT: Duplicate Variable < " + nm + " >";
          }
          _unique_var_validator.push(nm);
          return _vars.set_value.apply(_vars, [nm].concat(slice.call(args)));
        };
        VarCollector = (function(superClass) {
          extend(VarCollector, superClass);

          function VarCollector() {
            return VarCollector.__super__.constructor.apply(this, arguments);
          }

          VarCollector.prototype.visitSingleVariableDeclaration = function() {
            var args, decl, model, node, type;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            decl = this.visit.apply(this, [node.name].concat(slice.call(args)));
            type = this.visit.apply(this, [node.type].concat(slice.call(args)));
            model = new VarModel(type, false);
            return safe_vars_set(decl.name, model);
          };

          VarCollector.prototype.visitVariableDeclarationStatement = function() {
            var args, decl, decls, has_static, i, len, model, node, results, type;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            decls = this.visit.apply(this, [node.fragments].concat(slice.call(args)));
            type = this.visit.apply(this, [node.type].concat(slice.call(args)));
            has_static = this.constructor.has_modifier(node, 'static');
            model = new VarModel(type, has_static);
            results = [];
            for (i = 0, len = decls.length; i < len; i++) {
              decl = decls[i];
              results.push(safe_vars_set(decl.id.name, model));
            }
            return results;
          };

          VarCollector.prototype.visitFieldDeclaration = function() {
            var args, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.visitVariableDeclarationStatement.apply(this, [node].concat(slice.call(args)));
          };

          VarCollector.prototype.visitCatchClause = function() {
            var args, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.visit.apply(this, [node.exception].concat(slice.call(args)));
          };

          VarCollector.prototype.visitVariableDeclarationFragment = function() {
            var args, id, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            id = this.visit.apply(this, [node.name].concat(slice.call(args)));
            return builders.variableDeclarator(id, null);
          };

          VarCollector.prototype.visitForStatement = function() {
            var args, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.visit.apply(this, [node.initializers].concat(slice.call(args)));
          };

          VarCollector.prototype.visitVariableDeclarationExpression = function() {
            var args, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.visitVariableDeclarationStatement.apply(this, [node].concat(slice.call(args)));
          };

          VarCollector.prototype.visitAssignment = function() {
            var args, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return this.constructor.IGNORE_ME;
          };

          VarCollector.prototype.visitTypeDeclaration = function() {
            var args, node;
            node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            throw 'NotImpl: Nested | Inner classes ?';
          };

          return VarCollector;

        })(MicroVisitor);
        return new VarCollector().visit(src);
      };
      if (src) {
        this.collect_from(src);
      }
    }

    return VarScope;

  })();

  FieldScope = (function(superClass) {
    var clone, has_static, make_def_init;

    extend(FieldScope, superClass);

    clone = function(obj) {
      var flags, key, newInstance;
      if ((obj == null) || typeof obj !== 'object') {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof RegExp) {
        flags = '';
        if (obj.global != null) {
          flags += 'g';
        }
        if (obj.ignoreCase != null) {
          flags += 'i';
        }
        if (obj.multiline != null) {
          flags += 'm';
        }
        if (obj.sticky != null) {
          flags += 'y';
        }
        return new RegExp(obj.source, flags);
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = clone(obj[key]);
      }
      return newInstance;
    };

    has_static = function(node) {
      return MicroVisitor.has_modifier(node, 'static');
    };

    make_def_init = MicroVisitor.make_def_field_init;

    function FieldScope() {
      var _collect_from, _raw_inits, args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      FieldScope.__super__.constructor.apply(this, args);
      _raw_inits = [];
      this.get_raw_inits = function() {
        return slice.call(_raw_inits);
      };
      _collect_from = this.collect_from;
      this.collect_from = function(node) {
        var fragment, i, len, ref1;
        if (node.node !== 'FieldDeclaration') {
          throw "ASSERT: FieldDeclaration expected instead " + node.node;
        }
        if (!has_static(node)) {
          ref1 = node.fragments;
          for (i = 0, len = ref1.length; i < len; i++) {
            fragment = ref1[i];
            if (!fragment.initializer) {
              fragment = clone(fragment);
              fragment.initializer = make_def_init(node);
            }
            _raw_inits.push(fragment);
          }
        }
        return _collect_from(node);
      };
    }

    return FieldScope;

  })(VarScope);

  MemberScope = (function() {
    var MethodModel;

    MethodModel = (function() {
      function MethodModel(type1, overload1, _static) {
        this.type = type1;
        this.overload = overload1;
        this["static"] = _static;
      }

      return MethodModel;

    })();

    function MemberScope(ndcls) {
      var MembersCollector, _fields, _methods;
      _fields = new FieldScope;
      _methods = new Dict;
      MembersCollector = (function(superClass) {
        extend(MembersCollector, superClass);

        function MembersCollector() {
          return MembersCollector.__super__.constructor.apply(this, arguments);
        }

        MembersCollector.prototype.visitFieldDeclaration = function() {
          var args, node;
          node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return _fields.collect_from(node);
        };

        MembersCollector.prototype.visitMethodDeclaration = function() {
          var args, has_static, i, id, len, model, models, node, overload, retype;
          node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          id = this.visit.apply(this, [node.name].concat(slice.call(args)));
          retype = this.visit.apply(this, [node.returnType2].concat(slice.call(args)));
          models = _methods.get_value(id.name, []);
          overload = node.parameters.length;
          for (i = 0, len = models.length; i < len; i++) {
            model = models[i];
            if (overload === model.overload) {
              throw 'NotImpl: Overload by argumens type ' + id.name;
            }
          }
          has_static = this.constructor.has_modifier(node, 'static');
          models.push(new MethodModel(retype, overload, has_static));
          return _methods.set_value(id.name, models);
        };

        MembersCollector.prototype.visitTypeDeclaration = function() {
          var args, node;
          node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (node !== ndcls) {
            throw 'NotImpl: Nested | Inner classes ?';
          }
          this.visit.apply(this, [node.bodyDeclarations].concat(slice.call(args)));
          return this.visit.apply(this, [node.name].concat(slice.call(args)));
        };

        return MembersCollector;

      })(MicroVisitor);
      this.scope_id = new MembersCollector().visit(ndcls);
      this.fields = ['get_type', 'get_raw_inits', 'contains', 'is_static'].reduce(function(left, right) {
        return GenericVisitor.set_prop({
          obj: left,
          prop: right,
          value: _fields[right]
        });
      }, {});
      this.methods = {
        contains: (function(_this) {
          return function() {
            var args, ref1;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            return null !== (ref1 = _this.methods).get_type.apply(ref1, args);
          };
        })(this),
        get_type: function(name, params) {
          var i, len, model, ref1;
          ref1 = _methods.get_value(name, []);
          for (i = 0, len = ref1.length; i < len; i++) {
            model = ref1[i];
            if (params.length === model.overload) {
              return model.type;
            }
          }
          return null;
        },
        is_static: function(name, params) {
          var i, len, model, ref1;
          ref1 = _methods.get_value(name, []);
          for (i = 0, len = ref1.length; i < len; i++) {
            model = ref1[i];
            if (params.length === model.overload) {
              return !!model["static"];
            }
          }
          return false;
        },
        overload: function(name, params) {
          var ref1;
          if (((ref1 = _methods.get_value(name)) != null ? ref1.length : void 0) > 1) {
            return name + '$' + params.length;
          } else {
            if (_fields.contains(name)) {
              return name + '$fixed';
            } else {
              return name;
            }
          }
        }
      };
    }

    return MemberScope;

  })();

  ScopeVisitor = (function(superClass) {
    extend(ScopeVisitor, superClass);

    function ScopeVisitor() {
      return ScopeVisitor.__super__.constructor.apply(this, arguments);
    }

    ScopeVisitor.prototype.visitTypeDeclaration = function() {
      var args, members, node, su;
      node = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      members = new MemberScope(node);
      su = ScopeVisitor.__super__.visitTypeDeclaration.apply(this, [node, members].concat(slice.call(args)));
      return function(lazy) {
        return su(function(id, decls, su, inits) {
          return lazy(id, decls, su, inits, members);
        });
      };
    };

    ScopeVisitor.prototype.visitVariableDeclarationStatement = function() {
      var args, locals, members, node;
      node = arguments[0], members = arguments[1], locals = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      locals.collect_from(node);
      return ScopeVisitor.__super__.visitVariableDeclarationStatement.apply(this, [node, members, locals].concat(slice.call(args)));
    };

    ScopeVisitor.prototype.visitCatchClause = function() {
      var args, locals, members, node;
      node = arguments[0], members = arguments[1], locals = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      locals = locals.clone();
      locals.collect_from(node);
      return ScopeVisitor.__super__.visitCatchClause.apply(this, [node, members, locals].concat(slice.call(args)));
    };

    ScopeVisitor.prototype.visitForStatement = function() {
      var args, locals, members, node;
      node = arguments[0], members = arguments[1], locals = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      locals = locals.clone();
      locals.collect_from(node);
      return ScopeVisitor.__super__.visitForStatement.apply(this, [node, members, locals].concat(slice.call(args)));
    };

    ScopeVisitor.prototype.visitMethodDeclaration = function() {
      var args, locals, members, node, su;
      node = arguments[0], members = arguments[1], locals = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      locals = new VarScope(node.parameters);
      su = ScopeVisitor.__super__.visitMethodDeclaration.apply(this, [node, members, locals].concat(slice.call(args)));
      return function(lazy) {
        return su(function(id, params, body) {
          return lazy(id, params, body, locals);
        });
      };
    };

    ScopeVisitor.prototype.visitBlock = function() {
      var args, locals, members, node;
      node = arguments[0], members = arguments[1], locals = arguments[2], args = 4 <= arguments.length ? slice.call(arguments, 3) : [];
      return ScopeVisitor.__super__.visitBlock.apply(this, [node, members, locals.clone()].concat(slice.call(args)));
    };

    return ScopeVisitor;

  })(GenericVisitor);

  module.exports = ScopeVisitor;

}).call(this);
